
import { httpRequest } from "./request";
import config from "../config/index";
import { v4 as uuidv4 } from 'uuid';
import { produceModifiedMessages } from '../kafka/Listener'
import { createProjectCampaignResourcData, getHierarchy, handleResouceDetailsError, projectCreate } from "../api/campaignApis";
import { getCampaignNumber, createAndUploadFile, getSheetData, createExcelSheet, getAutoGeneratedBoundaryCodesHandler, getTargetSheetData, createBoundaryEntities, createBoundaryRelationship, getMDMSV1Data } from "../api/genericApis";
import { getFormattedStringForDebug, logger } from "./logger";
import createAndSearch from "../config/createAndSearch";
import * as XLSX from 'xlsx';
import { createReadMeSheet, findMapValue, getBoundaryRelationshipData, getLocalizedHeaders, getLocalizedMessagesHandler, modifyBoundaryData, modifyDataBasedOnDifferentTab, replicateRequest, throwError } from "./genericUtils";
import { enrichProjectDetailsFromCampaignDetails } from "./transforms/projectTypeUtils";
import { executeQuery } from "./db";
import { campaignDetailsTransformer, genericResourceTransformer } from "./transforms/searchResponseConstructor";
import { transformAndCreateLocalisation } from "./transforms/localisationMessageConstructor";
import { campaignStatuses, headingMapping, resourceDataStatuses } from "../config/constants";
import { getBoundaryColumnName, getBoundaryTabName } from "./boundaryUtils";
import { searchProjectTypeCampaignService } from "../service/campaignManageService";
import { validateBoundaryOfResouces } from "../validators/campaignValidators";
const _ = require('lodash');


function updateRange(range: any, desiredSheet: any) {
    let maxColumnIndex = 0;

    // Iterate through each row to find the last column with data
    for (let row = range.s.r; row <= range.e.r; row++) {
        for (let col = range.s.c; col <= range.e.c; col++) {
            const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });
            if (desiredSheet[cellAddress]) {
                maxColumnIndex = Math.max(maxColumnIndex, col);
            }
        }
    }

    // Update the end column of the range with the maximum column index found
    range.e.c = maxColumnIndex
}

function findColumns(desiredSheet: any): { statusColumn: string, errorDetailsColumn: string } {
    var range = XLSX.utils.decode_range(desiredSheet['!ref']);

    // Check if the status column already exists in the first row
    var statusColumn: any;
    for (let col = range.s.c; col <= range.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: range.s.r, c: col });
        if (desiredSheet[cellAddress] && desiredSheet[cellAddress].v === '#status#') {
            statusColumn = String.fromCharCode(65 + col);
            for (let row = range.s.r; row <= range.e.r; row++) {
                const cellAddress = XLSX.utils.encode_cell({ r: row, c: statusColumn.charCodeAt(0) - 65 });
                delete desiredSheet[cellAddress];
            }
            break;
        }
    }
    // Check if the errorDetails column already exists in the first row
    var errorDetailsColumn: any;
    for (let col = range.s.c; col <= range.e.c; col++) {
        const cellAddress = XLSX.utils.encode_cell({ r: range.s.r, c: col });
        if (desiredSheet[cellAddress] && desiredSheet[cellAddress].v === '#errorDetails#') {
            errorDetailsColumn = String.fromCharCode(65 + col);
            for (let row = range.s.r; row <= range.e.r; row++) {
                const cellAddress = XLSX.utils.encode_cell({ r: row, c: errorDetailsColumn.charCodeAt(0) - 65 });
                delete desiredSheet[cellAddress];
            }
            break;
        }
    }
    updateRange(range, desiredSheet);
    logger.info("Updated Range : " + JSON.stringify(range))
    // If the status column doesn't exist, calculate the next available column
    const emptyColumnIndex = range.e.c + 1;
    statusColumn = String.fromCharCode(65 + emptyColumnIndex);
    desiredSheet[statusColumn + '1'] = { v: '#status#', t: 's', r: '<t xml:space="preserve">#status#</t>', h: '#status#', w: '#status#' };

    // Calculate errorDetails column one column to the right of status column
    errorDetailsColumn = String.fromCharCode(statusColumn.charCodeAt(0) + 1);
    desiredSheet[errorDetailsColumn + '1'] = { v: '#errorDetails#', t: 's', r: '<t xml:space="preserve">#errorDetails#</t>', h: '#errorDetails#', w: '#errorDetails#' };
    return { statusColumn, errorDetailsColumn };
}

function processErrorData(request: any, createAndSearchConfig: any, workbook: any, sheetName: any, localizationMap?: { [key: string]: string }) {
    const desiredSheet: any = workbook.Sheets[sheetName];
    const errorData = request.body.sheetErrorDetails;
    const userNameAndPassword = request.body.userNameAndPassword;
    const columns = findColumns(desiredSheet);
    const statusColumn = columns.statusColumn;
    const errorDetailsColumn = columns.errorDetailsColumn;
    var additionalDetailsErrors: any[] = []
    if (errorData) {
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            const statusCell = statusColumn + (rowIndex + 1);
            const errorDetailsCell = errorDetailsColumn + (rowIndex + 1);
            desiredSheet[statusCell] = { v: error.status, t: 's', r: '<t xml:space="preserve">#status#</t>', h: error.status, w: error.status };
            desiredSheet[errorDetailsCell] = { v: error.errorDetails, t: 's', r: '<t xml:space="preserve">#errorDetails#</t>', h: error.errorDetails, w: error.errorDetails };
            if ((error?.status) && !(error?.status == "CREATED" || error?.status == "VALID")) {
                additionalDetailsErrors.push(error)
            }
        });
    }
    if (errorData) {
        const uniqueIdentifierFirstRowCell = createAndSearchConfig?.uniqueIdentifierColumn + 1
        const columnName = getLocalizedName(createAndSearchConfig?.uniqueIdentifierColumnName, localizationMap);
        desiredSheet[uniqueIdentifierFirstRowCell] = { v: columnName, t: 's', r: '<t xml:space="preserve">#uniqueIdentifier#</t>', h: columnName, w: columnName };
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            if (error.isUniqueIdentifier) {
                const uniqueIdentifierCell = createAndSearchConfig.uniqueIdentifierColumn + (rowIndex + 1);
                desiredSheet[uniqueIdentifierCell] = { v: error.uniqueIdentifier, t: 's', r: '<t xml:space="preserve">#uniqueIdentifier#</t>', h: error.uniqueIdentifier, w: error.uniqueIdentifier };
            }
        });
    }
    request.body.additionalDetailsErrors = additionalDetailsErrors
    // lastcolumn = max of createAndSearchConfig?.uniqueIdentifierColumn and errorDetailsColumn
    let lastColumn: string = errorDetailsColumn;

    if (createAndSearchConfig?.uniqueIdentifierColumn !== undefined) {
        // Compare strings lexicographically
        lastColumn = createAndSearchConfig?.uniqueIdentifierColumn > errorDetailsColumn ?
            createAndSearchConfig?.uniqueIdentifierColumn :
            errorDetailsColumn;
    }
    if (userNameAndPassword) {
        const userNameFirstCell = "I" + 1;
        const passwordFirstCell = "J" + 1;
        desiredSheet[userNameFirstCell] = { v: "UserName", t: 's', r: '<t xml:space="preserve">UserName</t>', h: "UserName", w: "UserName" };
        desiredSheet[passwordFirstCell] = { v: "Password", t: 's', r: '<t xml:space="preserve">Password</t>', h: "Password", w: "Password" };
        userNameAndPassword.forEach((data: any) => {
            const rowIndex = data.rowNumber;
            const userNameCell = "I" + (rowIndex + 1);
            const passWordCell = "J" + (rowIndex + 1);
            desiredSheet[userNameCell] = { v: data?.userName, t: 's', r: '<t xml:space="preserve">UserName</t>', h: data?.userName, w: data?.userName };
            desiredSheet[passWordCell] = { v: data?.password, t: 's', r: '<t xml:space="preserve">Password</t>', h: data?.password, w: data?.password };
        });
        lastColumn = "J";
        delete request.body.userNameAndPassword;
    }
    desiredSheet['!ref'] = desiredSheet['!ref'].replace(/:[A-Z]+/, ':' + lastColumn);
    workbook.Sheets[sheetName] = desiredSheet;
}

function processErrorDataForTargets(request: any, createAndSearchConfig: any, workbook: any, sheetName: any) {
    const desiredSheet: any = workbook.Sheets[sheetName];
    const columns = findColumns(desiredSheet);
    const statusColumn = columns.statusColumn;
    const errorDetailsColumn = columns.errorDetailsColumn;

    const errorData = request.body.sheetErrorDetails.filter((error: any) => error.sheetName === sheetName);
    var additionalDetailsErrors: any[] = []

    if (errorData) {
        errorData.forEach((error: any) => {
            const rowIndex = error.rowNumber;
            if (error.isUniqueIdentifier) {
                const uniqueIdentifierCell = createAndSearchConfig.uniqueIdentifierColumn + (rowIndex + 1);
                desiredSheet[uniqueIdentifierCell] = { v: error.uniqueIdentifier, t: 's', r: '<t xml:space="preserve">#uniqueIdentifier#</t>', h: error.uniqueIdentifier, w: error.uniqueIdentifier };
            }

            const statusCell = statusColumn + (rowIndex + 1);
            const errorDetailsCell = errorDetailsColumn + (rowIndex + 1);
            desiredSheet[statusCell] = { v: error.status, t: 's', r: '<t xml:space="preserve">#status#</t>', h: error.status, w: error.status };
            desiredSheet[errorDetailsCell] = { v: error.errorDetails, t: 's', r: '<t xml:space="preserve">#errorDetails#</t>', h: error.errorDetails, w: error.errorDetails };
            if (!(error?.status == "CREATED" || error?.status == "VALID")) {
                additionalDetailsErrors.push(error)
            }
        });
    }
    request.body.additionalDetailsErrors = additionalDetailsErrors
    desiredSheet['!ref'] = desiredSheet['!ref'].replace(/:[A-Z]+/, ':' + errorDetailsColumn);
    workbook.Sheets[sheetName] = desiredSheet;
}

async function updateStatusFile(request: any, localizationMap?: { [key: string]: string }) {
    const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
    const tenantId = request?.body?.ResourceDetails?.tenantId;
    const createAndSearchConfig = createAndSearch[request?.body?.ResourceDetails?.type];
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileStoreId }, "get");

    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "INVALID_FILE");
    }

    const headers = {
        'Content-Type': 'application/json',
        Accept: 'application/pdf',
    };

    const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;
    const sheetName = createAndSearchConfig?.parseArrayConfig?.sheetName;
    const localizedSheetName = getLocalizedName(sheetName, localizationMap)
    const responseFile = await httpRequest(fileUrl, null, {}, 'get', 'arraybuffer', headers);
    const workbook = XLSX.read(responseFile, { type: 'buffer' });
    // Check if the specified sheet exists in the workbook
    if (!workbook.Sheets.hasOwnProperty(localizedSheetName)) {
        throwError("FILE", 400, "INVALID_SHEETNAME", `Sheet with name "${localizedSheetName}" is not present in the file.`);
    }
    processErrorData(request, createAndSearchConfig, workbook, localizedSheetName, localizationMap);
    const sheet = workbook.Sheets[localizedSheetName];
    const columnWidths = Array(12).fill({ width: 30 });
    sheet['!cols'] = columnWidths;
    const responseData = await createAndUploadFile(workbook, request);
    logger.info('File updated successfully:' + JSON.stringify(responseData));
    if (responseData?.[0]?.fileStoreId) {
        request.body.ResourceDetails.processedFileStoreId = responseData?.[0]?.fileStoreId;
    }
    else {
        throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
    }
}
async function updateStatusFileForTargets(request: any, localizationMap?: { [key: string]: string }) {
    const fileStoreId = request?.body?.ResourceDetails?.fileStoreId;
    const tenantId = request?.body?.ResourceDetails?.tenantId;
    const createAndSearchConfig = createAndSearch[request?.body?.ResourceDetails?.type];
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileStoreId }, "get");

    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "INVALID_FILE");
    }

    const headers = {
        'Content-Type': 'application/json',
        Accept: 'application/pdf',
    };

    const fileUrl = fileResponse?.fileStoreIds?.[0]?.url;
    const responseFile = await httpRequest(fileUrl, null, {}, 'get', 'arraybuffer', headers);
    const workbook = XLSX.read(responseFile, { type: 'buffer' });
    const sheetNames = workbook.SheetNames;
    const localizedSheetNames = getLocalizedHeaders(sheetNames, localizationMap)
    localizedSheetNames.forEach((sheetName: any) => {
        if (sheetName != getLocalizedName(config.boundaryTab, localizationMap) && sheetName != getLocalizedName(config.readMeTab, localizationMap)) {
            processErrorDataForTargets(request, createAndSearchConfig, workbook, sheetName);
        }
    });




    const responseData = await createAndUploadFile(workbook, request);
    logger.info('File updated successfully:' + JSON.stringify(responseData));
    if (responseData?.[0]?.fileStoreId) {
        request.body.ResourceDetails.processedFileStoreId = responseData?.[0]?.fileStoreId;
    }
    else {
        throwError("FILE", 500, "STATUS_FILE_CREATION_ERROR");
    }
}


function convertToType(dataToSet: any, type: any) {
    switch (type) {
        case "string":
            return String(dataToSet);
        case "number":
            return Number(dataToSet);
        case "boolean":
            // Convert to boolean assuming any truthy value should be true and falsy should be false
            return Boolean(dataToSet);
        // Add more cases if needed for other types
        default:
            // If type is not recognized, keep dataToSet as it is
            return dataToSet;
    }
}

function setTenantId(
    resultantElement: any,
    requestBody: any,
    createAndSearchConfig: any
) {
    if (createAndSearchConfig?.parseArrayConfig?.tenantId) {
        const tenantId = _.get(requestBody, createAndSearchConfig?.parseArrayConfig?.tenantId?.getValueViaPath);
        _.set(resultantElement, createAndSearchConfig?.parseArrayConfig?.tenantId?.resultantPath, tenantId);
    }

}


async function processData(request: any, dataFromSheet: any[], createAndSearchConfig: any, localizationMap?: { [key: string]: string }) {
    const parseLogic = createAndSearchConfig?.parseArrayConfig?.parseLogic;
    const requiresToSearchFromSheet = createAndSearchConfig?.requiresToSearchFromSheet;
    var createData = [], searchData = [];
    for (const data of dataFromSheet) {
        const resultantElement: any = {};
        for (const element of parseLogic) {
            if (element?.resultantPath) {
                const localizedSheetColumnName = getLocalizedName(element.sheetColumnName, localizationMap);
                let dataToSet = _.get(data, localizedSheetColumnName);
                if (element.conversionCondition) {
                    dataToSet = element.conversionCondition[dataToSet];
                }
                if (element.type) {
                    dataToSet = convertToType(dataToSet, element.type);
                }
                _.set(resultantElement, element.resultantPath, dataToSet);
            }
        }
        resultantElement["!row#number!"] = data["!row#number!"];
        var addToCreate = true;
        if (requiresToSearchFromSheet) {
            for (const key of requiresToSearchFromSheet) {
                const localizedSheetColumnName = getLocalizedName(key.sheetColumnName, localizationMap);
                if (data[localizedSheetColumnName]) {
                    searchData.push(resultantElement)
                    addToCreate = false;
                    break;
                }
            }
        }
        if (addToCreate) {
            createData.push(resultantElement)
        }
    }
    return { searchData, createData };
}

function setTenantIdAndSegregate(processedData: any, createAndSearchConfig: any, requestBody: any) {
    for (const resultantElement of processedData.createData) {
        setTenantId(resultantElement, requestBody, createAndSearchConfig);
    }
    for (const resultantElement of processedData.searchData) {
        setTenantId(resultantElement, requestBody, createAndSearchConfig);
    }
    return processedData;
}

// Original function divided into two parts
async function convertToTypeData(request: any, dataFromSheet: any[], createAndSearchConfig: any, requestBody: any, localizationMap?: { [key: string]: string }) {
    const processedData = await processData(request, dataFromSheet, createAndSearchConfig, localizationMap);
    return setTenantIdAndSegregate(processedData, createAndSearchConfig, requestBody);
}

function updateActivityResourceId(request: any) {
    if (request?.body?.Activities && Array.isArray(request?.body?.Activities)) {
        for (const activity of request?.body?.Activities) {
            activity.resourceDetailsId = request?.body?.ResourceDetails?.id
        }
    }
}

async function generateProcessedFileAndPersist(request: any, localizationMap?: { [key: string]: string }) {
    if (request.body.ResourceDetails.type == 'boundaryWithTarget') {
        await updateStatusFileForTargets(request, localizationMap);
    } else {
        if (request.body.ResourceDetails.type !== "boundary") {
            await updateStatusFile(request, localizationMap);
        }
    }
    updateActivityResourceId(request);
    request.body.ResourceDetails = {
        ...request?.body?.ResourceDetails,
        status: request.body.ResourceDetails.status != resourceDataStatuses.invalid ? resourceDataStatuses.completed : resourceDataStatuses.invalid,
        auditDetails: {
            ...request?.body?.ResourceDetails?.auditDetails,
            lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
            lastModifiedTime: Date.now()
        },
        additionalDetails: { ...request?.body?.ResourceDetails?.additionalDetails, sheetErrors: request?.body?.additionalDetailsErrors } || {}
    };
    produceModifiedMessages(request?.body, config.KAFKA_UPDATE_RESOURCE_DETAILS_TOPIC);
    logger.info("ResourceDetails to persist : " + JSON.stringify(request?.body?.ResourceDetails));
    if (request?.body?.Activities && Array.isArray(request?.body?.Activities && request?.body?.Activities.length > 0)) {
        logger.info("Activities to persist : " + JSON.stringify(request?.body?.Activities));
        await new Promise(resolve => setTimeout(resolve, 2000));
        produceModifiedMessages(request?.body, config.KAFKA_CREATE_RESOURCE_ACTIVITY_TOPIC);
    }
}

function getRootBoundaryCode(boundaries: any[] = []) {
    for (const boundary of boundaries) {
        if (boundary.isRoot) {
            return boundary.code;
        }
    }
    return "";
}

function enrichRootProjectId(requestBody: any) {
    var rootBoundary;
    for (const boundary of requestBody?.CampaignDetails?.boundaries) {
        if (boundary?.isRoot) {
            rootBoundary = boundary?.code
            break;
        }
    }
    if (rootBoundary) {
        requestBody.CampaignDetails.projectId = requestBody?.boundaryProjectMapping?.[rootBoundary]?.projectId || null
    }
    requestBody.CampaignDetails.projectId = requestBody.CampaignDetails.projectId || null
}

async function enrichAndPersistCampaignWithError(requestBody: any, error: any) {
    requestBody.CampaignDetails = requestBody?.CampaignDetails || {}
    const action = requestBody?.CampaignDetails?.action;
    requestBody.CampaignDetails.campaignNumber = requestBody?.CampaignDetails?.campaignNumber || null
    requestBody.CampaignDetails.campaignDetails = requestBody?.CampaignDetails?.campaignDetails || { deliveryRules: requestBody?.CampaignDetails?.deliveryRules, resources: requestBody?.CampaignDetails?.resources || [], boundaries: requestBody?.CampaignDetails?.boundaries || [] };
    requestBody.CampaignDetails.status = campaignStatuses?.failed;
    requestBody.CampaignDetails.boundaryCode = getRootBoundaryCode(requestBody?.CampaignDetails?.boundaries) || null
    requestBody.CampaignDetails.projectType = requestBody?.CampaignDetails?.projectType || null;
    requestBody.CampaignDetails.hierarchyType = requestBody?.CampaignDetails?.hierarchyType || null;
    requestBody.CampaignDetails.additionalDetails = requestBody?.CampaignDetails?.additionalDetails || {};
    requestBody.CampaignDetails.startDate = requestBody?.CampaignDetails?.startDate || null
    requestBody.CampaignDetails.endDate = requestBody?.CampaignDetails?.endDate || null
    requestBody.CampaignDetails.auditDetails = {
        createdBy: requestBody?.RequestInfo?.userInfo?.uuid,
        createdTime: Date.now(),
        lastModifiedBy: requestBody?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !requestBody?.CampaignDetails?.projectId) {
        enrichRootProjectId(requestBody);
    }
    else if (!requestBody?.CampaignDetails?.projectId) {
        requestBody.CampaignDetails.projectId = null
    }
    requestBody.CampaignDetails.additionalDetails = {
        ...requestBody?.CampaignDetails?.additionalDetails,
        error: String((error?.message + " : " + error?.description) || error)
    }
    const topic = config.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    produceModifiedMessages(requestBody, topic);
    delete requestBody.CampaignDetails.campaignDetails
}

async function enrichAndPersistCampaignForCreate(request: any, firstPersist: boolean = false) {
    const action = request?.body?.CampaignDetails?.action;
    if (firstPersist) {
        request.body.CampaignDetails.campaignNumber = await getCampaignNumber(request.body, "CMP-[cy:yyyy-MM-dd]-[SEQ_EG_CMP_ID]", "campaign.number", request?.body?.CampaignDetails?.tenantId);
    }
    request.body.CampaignDetails.campaignDetails = { deliveryRules: request?.body?.CampaignDetails?.deliveryRules || [], resources: request?.body?.CampaignDetails?.resources || [], boundaries: request?.body?.CampaignDetails?.boundaries || [] };
    request.body.CampaignDetails.status = action == "create" ? campaignStatuses.started : campaignStatuses.drafted;
    request.body.CampaignDetails.boundaryCode = getRootBoundaryCode(request.body.CampaignDetails.boundaries)
    request.body.CampaignDetails.projectType = request?.body?.CampaignDetails?.projectType || null;
    request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails?.hierarchyType || null;
    request.body.CampaignDetails.additionalDetails = request?.body?.CampaignDetails?.additionalDetails || {};
    request.body.CampaignDetails.startDate = request?.body?.CampaignDetails?.startDate || null
    request.body.CampaignDetails.endDate = request?.body?.CampaignDetails?.endDate || null
    request.body.CampaignDetails.auditDetails = {
        createdBy: request?.body?.RequestInfo?.userInfo?.uuid,
        createdTime: Date.now(),
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !request?.body?.CampaignDetails?.projectId && !firstPersist) {
        enrichRootProjectId(request.body);
    }
    else {
        request.body.CampaignDetails.projectId = null
    }
    const topic = firstPersist ? config.KAFKA_SAVE_PROJECT_CAMPAIGN_DETAILS_TOPIC : config.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC
    delete request.body.CampaignDetails.codesTargetMapping
    produceModifiedMessages(request?.body, topic);
    delete request.body.CampaignDetails.campaignDetails
}

function enrichInnerCampaignDetails(request: any, updatedInnerCampaignDetails: any) {
    updatedInnerCampaignDetails.resources = request?.body?.CampaignDetails?.resources || []
    updatedInnerCampaignDetails.deliveryRules = request?.body?.CampaignDetails?.deliveryRules || []
    updatedInnerCampaignDetails.boundaries = request?.body?.CampaignDetails?.boundaries || []
}

async function enrichAndPersistCampaignForUpdate(request: any, firstPersist: boolean = false) {
    const action = request?.body?.CampaignDetails?.action;
    const ExistingCampaignDetails = request?.body?.ExistingCampaignDetails;
    var updatedInnerCampaignDetails = {}
    enrichInnerCampaignDetails(request, updatedInnerCampaignDetails)
    request.body.CampaignDetails.campaignNumber = ExistingCampaignDetails?.campaignNumber
    request.body.CampaignDetails.campaignDetails = updatedInnerCampaignDetails
    request.body.CampaignDetails.status = action == "create" ? campaignStatuses.started : campaignStatuses.drafted;
    const boundaryCode = !(request?.body?.CampaignDetails?.projectId) ? getRootBoundaryCode(request.body.CampaignDetails.boundaries) : (request?.body?.CampaignDetails?.boundaryCode || ExistingCampaignDetails?.boundaryCode)
    request.body.CampaignDetails.boundaryCode = boundaryCode
    request.body.CampaignDetails.startDate = request?.body?.CampaignDetails?.startDate || ExistingCampaignDetails?.startDate || null
    request.body.CampaignDetails.endDate = request?.body?.CampaignDetails?.endDate || ExistingCampaignDetails?.endDate || null
    request.body.CampaignDetails.projectType = request?.body?.CampaignDetails?.projectType ? request?.body?.CampaignDetails?.projectType : ExistingCampaignDetails?.projectType
    request.body.CampaignDetails.hierarchyType = request?.body?.CampaignDetails?.hierarchyType ? request?.body?.CampaignDetails?.hierarchyType : ExistingCampaignDetails?.hierarchyType
    request.body.CampaignDetails.additionalDetails = request?.body?.CampaignDetails?.additionalDetails ? request?.body?.CampaignDetails?.additionalDetails : ExistingCampaignDetails?.additionalDetails
    request.body.CampaignDetails.auditDetails = {
        createdBy: ExistingCampaignDetails?.createdBy,
        createdTime: ExistingCampaignDetails?.createdTime,
        lastModifiedBy: request?.body?.RequestInfo?.userInfo?.uuid,
        lastModifiedTime: Date.now(),
    }
    if (action == "create" && !request?.body?.CampaignDetails?.projectId) {
        enrichRootProjectId(request.body);
    }
    else {
        request.body.CampaignDetails.projectId = request?.body?.CampaignDetails?.projectId || ExistingCampaignDetails?.projectId || null
    }
    delete request.body.CampaignDetails.codesTargetMapping
    produceModifiedMessages(request?.body, config.KAFKA_UPDATE_PROJECT_CAMPAIGN_DETAILS_TOPIC);
    delete request.body.ExistingCampaignDetails
    delete request.body.CampaignDetails.campaignDetails
}

function getCreateResourceIds(resources: any[]) {
    return resources
        .filter((resource: any) => typeof resource.createResourceId === 'string' && resource.createResourceId.trim() !== '')
        .map((resource: any) => {
            const resourceId = resource.createResourceId;
            return resourceId;
        });
}

async function persistForCampaignProjectMapping(request: any, createResourceDetailsIds: any, localizationMap?: any) {
    if (createResourceDetailsIds && request?.body?.CampaignDetails?.projectId) {
        var requestBody: any = {
            RequestInfo: request?.body?.RequestInfo,
            Campaign: {}
        }
        requestBody.Campaign.id = request?.body?.CampaignDetails?.id
        requestBody.Campaign.hierarchyType = request?.body?.CampaignDetails?.hierarchyType
        requestBody.Campaign.tenantId = request?.body?.CampaignDetails?.tenantId
        requestBody.Campaign.campaignName = request?.body?.CampaignDetails?.campaignName
        requestBody.Campaign.boundaryCode = request?.body?.CampaignDetails?.boundaryCode
        requestBody.Campaign.startDate = request?.body?.CampaignDetails?.startDate
        requestBody.Campaign.endDate = request?.body?.CampaignDetails?.endDate
        requestBody.Campaign.projectType = request?.body?.CampaignDetails?.projectType
        requestBody.Campaign.additionalDetails = request?.body?.CampaignDetails?.additionalDetails
        requestBody.Campaign.deliveryRules = request?.body?.CampaignDetails?.deliveryRules
        requestBody.Campaign.rootProjectId = request?.body?.CampaignDetails?.projectId
        requestBody.Campaign.resourceDetailsIds = createResourceDetailsIds
        requestBody.CampaignDetails = request?.body?.CampaignDetails
        var updatedInnerCampaignDetails = {}
        enrichInnerCampaignDetails(request, updatedInnerCampaignDetails)
        requestBody.CampaignDetails = request?.body?.CampaignDetails
        requestBody.CampaignDetails.campaignDetails = updatedInnerCampaignDetails
        requestBody.localizationMap = localizationMap
        logger.info("Persisting CampaignProjectMapping : " + JSON.stringify(requestBody));
        produceModifiedMessages(requestBody, config.KAFKA_START_CAMPAIGN_MAPPING_TOPIC);
    }
}


async function enrichAndPersistProjectCampaignRequest(request: any, actionInUrl: any, firstPersist: boolean = false, localizationMap?: any) {
    var createResourceDetailsIds: any[] = []
    if (request?.body?.CampaignDetails?.resources && Array.isArray(request?.body?.CampaignDetails?.resources) && request?.body?.CampaignDetails?.resources?.length > 0 && request?.body?.CampaignDetails?.action == "create") {
        createResourceDetailsIds = getCreateResourceIds(request?.body?.CampaignDetails?.resources);
    }
    if (actionInUrl == "create") {
        await enrichAndPersistCampaignForCreate(request, firstPersist)
    }
    else if (actionInUrl == "update") {
        await enrichAndPersistCampaignForUpdate(request, firstPersist)
    }
    if (request?.body?.CampaignDetails?.action == "create") {
        await persistForCampaignProjectMapping(request, createResourceDetailsIds, localizationMap);
    }
}

function getChildParentMap(modifiedBoundaryData: any) {
    const childParentMap: Map<{ key: string, value: string }, { key: string, value: string } | null> = new Map();

    modifiedBoundaryData.forEach((row: any) => {
        for (let j = row.length - 1; j >= 0; j--) {
            const child = row[j];
            const parent = j - 1 >= 0 ? row[j - 1] : null;
            const childIdentifier = { key: child.key, value: child.value }; // Unique identifier for the child
            const parentIdentifier = parent ? { key: parent.key, value: parent.value } : null; // Unique identifier for the parent, set to null if parent doesn't exist


            // Check if the mapping already exists in the childParentMap
            const existingMapping = Array.from(childParentMap.entries()).find(([existingChild, existingParent]) =>
                _.isEqual(existingChild, childIdentifier) && _.isEqual(existingParent, parentIdentifier)
            );

            // If the mapping doesn't exist, add it to the childParentMap
            if (!existingMapping) {
                childParentMap.set(childIdentifier, parentIdentifier);
            }
        }
    });
    return childParentMap;
}






function getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode: any[]) {
    const countMap = new Map<{ key: string, value: string }, number>();
    const mappingMap = new Map<{ key: string, value: string }, string>();

    withBoundaryCode.forEach((row: any[]) => {
        const len = row.length;
        if (len >= 3) {
            let grandParentFound = false;
            const grandParent = row[len - 3];
            if (findMapValue(mappingMap, grandParent)) {
                const countMapArray = Array.from(countMap.entries());
                for (const [key, value] of countMapArray) {
                    if (_.isEqual(key, grandParent)) {
                        countMap.set(key, value + 1);
                        grandParentFound = true;
                        break;
                    }
                }
                if (grandParentFound == false) {
                    countMap.set(grandParent, 1);
                }
            }
        }
        mappingMap.set(row[len - 2], row[len - 1].value);
    });
    return { mappingMap, countMap };
}


function addBoundaryCodeToData(withBoundaryCode: any[], withoutBoundaryCode: any[], boundaryMap: Map<any, any>) {
    const boundaryDataWithBoundaryCode = withBoundaryCode;
    const modifiedBoundaryDataWithBoundaryCode = boundaryDataWithBoundaryCode.map((array) => {
        return array.map((obj: any) => {
            if (obj.key === 'Boundary Code') {
                return obj.value;
            } else {
                return obj;
            }
        });
    });

    const boundaryDataForWithoutBoundaryCode = withoutBoundaryCode.map((row: any[]) => {
        const boundaryName = row[row.length - 1]; // Get the last element of the row
        const boundaryCode = findMapValue(boundaryMap, boundaryName); // Fetch corresponding boundary code from map
        return [...row, boundaryCode]; // Append boundary code to the row and return updated row
    });
    const boundaryDataForSheet = [...modifiedBoundaryDataWithBoundaryCode, ...boundaryDataForWithoutBoundaryCode];
    return boundaryDataForSheet;
}

function prepareDataForExcel(boundaryDataForSheet: any, hierarchy: any[], boundaryMap: any) {
    const data = boundaryDataForSheet.map((boundary: any[]) => {
        const boundaryCode = boundary.pop();
        const boundaryValues = boundary.map(obj => obj.value);
        const rowData = boundaryValues.concat(Array(Math.max(0, hierarchy.length - boundary.length)).fill(''));
        const boundaryCodeIndex = hierarchy.length;
        rowData[boundaryCodeIndex] = boundaryCode;
        return rowData;
    });
    return data;
}
function extractCodesFromBoundaryRelationshipResponse(boundaries: any[]): any {
    const codes = new Set();
    for (const boundary of boundaries) {
        codes.add(boundary.code); // Add code to the Set
        if (boundary.children && boundary.children.length > 0) {
            const childCodes = extractCodesFromBoundaryRelationshipResponse(boundary.children); // Recursively get child codes
            childCodes.forEach((code: any) => codes.add(code)); // Add child codes to the Set
        }
    }
    return codes;
}


async function getTotalCount(request: any) {
    const CampaignDetails = request.body.CampaignDetails;
    const { tenantId, pagination, ids, ...searchFields } = CampaignDetails;
    let conditions = [];
    let values = [tenantId];
    let index = 2;
    const campaignsIncludeDates = searchFields?.campaignsIncludeDates

    for (const field in searchFields) {
        if (searchFields[field] !== undefined && field != 'campaignsIncludeDates') {
            if (field === 'startDate') {
                const startDateSign = campaignsIncludeDates ? '<=' : '>=';
                conditions.push(`startDate ${startDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'endDate') {
                const endDateSign = campaignsIncludeDates ? '>=' : '<=';
                conditions.push(`endDate ${endDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'campaignName') {
                conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
                values.push(searchFields[field]);
                index++;
            } else if (field != 'status') {
                conditions.push(`${field} = $${index}`);
                values.push(searchFields[field]);
                index++;
            }
        }
    }

    let query = `
        SELECT count(*)
        FROM health.eg_cm_campaign_details
        WHERE tenantId = $1
    `;

    if (ids && ids.length > 0) {
        const idParams = ids.map((id: any, i: any) => `$${index + i}`);
        query += ` AND id IN (${idParams.join(', ')})`;
        values.push(...ids);
        index = index + ids.length;
    }
    var status = searchFields?.status;
    if (status) {
        if (typeof status === 'string') {
            status = [status]; // Convert string to array
        }
        const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
        query += ` AND status IN (${statusParams.join(', ')})`;
        values.push(...status);
    }

    if (conditions.length > 0) {
        query += ` AND ${conditions.join(' AND ')}`;
    }
    const queryResult = await executeQuery(query, values);
    const totalCount = parseInt(queryResult.rows[0].count, 10);
    request.body.totalCount = totalCount;
}




async function searchProjectCampaignResourcData(request: any) {
    const CampaignDetails = request.body.CampaignDetails;
    const { tenantId, pagination, ids, ...searchFields } = CampaignDetails;
    const queryData = buildSearchQuery(tenantId, pagination, ids, searchFields);
    await getTotalCount(request)
    const responseData: any[] = await executeSearchQuery(queryData.query, queryData.values);
    // TODO @ashish check the below code looks like duplicate
    for (const data of responseData) {
        data.resources = data?.campaignDetails?.resources
        data.boundaries = data?.campaignDetails?.boundaries
        data.deliveryRules = data?.campaignDetails?.deliveryRules;
        delete data.campaignDetails;
        data.auditDetails = {
            createdBy: data?.createdBy,
            lastModifiedBy: data?.lastModifiedBy,
            createdTime: data?.createdTime,
            lastModifiedTime: data?.lastModifiedTime
        }
        delete data.createdBy;
        delete data.lastModifiedBy;
        delete data.createdTime;
        delete data.lastModifiedTime;
    }
    request.body.CampaignDetails = responseData;
}

function buildSearchQuery(tenantId: string, pagination: any, ids: string[], searchFields: any): { query: string, values: any[] } {
    let conditions = [];
    let values = [tenantId];
    let index = 2;
    const campaignsIncludeDates = searchFields?.campaignsIncludeDates

    for (const field in searchFields) {
        if (searchFields[field] !== undefined && field != 'campaignsIncludeDates') {
            if (field === 'startDate') {
                const startDateSign = campaignsIncludeDates ? '<=' : '>=';
                conditions.push(`startDate ${startDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'endDate') {
                const endDateSign = campaignsIncludeDates ? '>=' : '<=';
                conditions.push(`endDate ${endDateSign} $${index}`);
                values.push(searchFields[field]);
                index++;
            } else if (field === 'campaignName') {
                conditions.push(`${field} ILIKE '%' || $${index} || '%'`);
                values.push(searchFields[field]);
                index++;
            } else if (field != 'status') {
                conditions.push(`${field} = $${index}`);
                values.push(searchFields[field]);
                index++;
            }
        }
    }

    let query = `
        SELECT *
        FROM health.eg_cm_campaign_details
        WHERE tenantId = $1
    `;

    if (ids && ids.length > 0) {
        const idParams = ids.map((id: any, i: any) => `$${index + i}`);
        query += ` AND id IN (${idParams.join(', ')})`;
        values.push(...ids);
        index = index + ids.length;
    }

    var status = searchFields?.status;
    if (status) {
        if (typeof status === 'string') {
            status = [status]; // Convert string to array
        }
        const statusParams = status.map((param: any, i: any) => `$${index + i}`); // Increment index for each parameter
        query += ` AND status IN (${statusParams.join(', ')})`;
        values.push(...status);
    }

    if (conditions.length > 0) {
        query += ` AND ${conditions.join(' AND ')}`;
    }

    if (pagination) {
        query += '\n';

        if (pagination.sortBy) {
            query += `ORDER BY ${pagination.sortBy}`;
            if (pagination.sortOrder) {
                query += ` ${pagination.sortOrder.toUpperCase()}`;
            }
            query += '\n';
        }

        if (pagination.limit !== undefined) {
            query += `LIMIT ${pagination.limit}`;
            if (pagination.offset !== undefined) {
                query += ` OFFSET ${pagination.offset}`;
            }
            query += '\n';
        }
    }

    return { query, values };
}



async function executeSearchQuery(query: string, values: any[]) {
    const queryResult = await executeQuery(query, values);
    return campaignDetailsTransformer(queryResult?.rows);
}

async function processDataSearchRequest(request: any) {
    const { SearchCriteria } = request.body;
    const query = buildWhereClauseForDataSearch(SearchCriteria);
    const queryResult = await executeQuery(query.query, query.values);
    request.body.ResourceDetails = genericResourceTransformer(queryResult?.rows);;
}

function buildWhereClauseForDataSearch(SearchCriteria: any): { query: string; values: any[] } {
    const { id, tenantId, type, status } = SearchCriteria;
    let conditions = [];
    let values = [];

    if (id && id.length > 0) {
        conditions.push(`id = ANY($${values.length + 1})`);
        values.push(id);
    }

    if (tenantId) {
        conditions.push(`tenantId = $${values.length + 1}`);
        values.push(tenantId);
    }

    if (type) {
        conditions.push(`type = $${values.length + 1}`);
        values.push(type);
    }

    if (status) {
        conditions.push(`status = $${values.length + 1}`);
        values.push(status);
    }

    const whereClause = conditions.length > 0 ? `WHERE ${conditions.join(' AND ')}` : '';

    return {
        query: `
    SELECT *
    FROM health.eg_cm_resource_details
    ${whereClause};`, values
    };
}

function mapBoundariesParent(boundaryResponses: any, request: any, parent: any) {
    if (!boundaryResponses) return;

    for (const boundaryResponse of boundaryResponses) {
        request.body.boundaryProjectMapping[boundaryResponse.code] = {
            parent: parent || null,
            projectId: null
        }
        if (boundaryResponse?.children && Array.isArray(boundaryResponse?.children) && boundaryResponse?.children?.length > 0) {
            mapBoundariesParent(boundaryResponse.children, request, boundaryResponse.code);
        }
    }
}

function mapTargets(boundaryResponses: any, codesTargetMapping: any) {
    if (!boundaryResponses || !codesTargetMapping) return;

    for (const boundaryResponse of boundaryResponses) {
        const mapBoundary = (boundary: any) => {
            if (!boundary.children || boundary.children.length === 0) {
                const targetValue = codesTargetMapping[boundary.code];
                return targetValue ? targetValue : 0;
            }

            let totalTargetValue = 0;
            for (const child of boundary.children) {
                const childTargetValue = mapBoundary(child);
                totalTargetValue += childTargetValue;
            }
            codesTargetMapping[boundary.code] = totalTargetValue;
            return totalTargetValue;
        };
        mapBoundary(boundaryResponse);
    }
}

async function processBoundaryForData(boundary: any, boundaryCodes: any, boundaries: any[], request: any, includeAllChildren: any = false, parent?: any) {
    if (!boundaryCodes.has(boundary.code)) {
        boundaries.push({ code: boundary?.code, type: boundary?.boundaryType });
        boundaryCodes.add(boundary?.code);
    }
    if (boundary?.includeAllChildren || includeAllChildren) {
        const params = {
            tenantId: request?.body?.ResourceDetails?.tenantId,
            codes: boundary?.code,
            hierarchyType: request?.body?.ResourceDetails?.hierarchyType,
            includeChildren: true
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params);
        if (boundaryResponse?.TenantBoundary?.[0]) {
            logger.info("Boundary found " + JSON.stringify(boundaryResponse?.TenantBoundary?.[0]?.boundary));
            if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]?.children) {
                for (const childBoundary of boundaryResponse.TenantBoundary[0]?.boundary?.[0].children) {
                    await processBoundaryForData(childBoundary, boundaryCodes, boundaries, request, true, boundary?.code);
                }
            }
        }
    }
}


async function processBoundary(boundary: any, boundaryCodes: any, boundaries: any[], request: any, includeAllChildren: any = false, parent?: any) {
    if (!boundaryCodes.has(boundary.code)) {
        boundaries.push({ code: boundary?.code, type: boundary?.boundaryType });
        boundaryCodes.add(boundary?.code);
    }
    if (boundary?.includeAllChildren || includeAllChildren) {
        const params = {
            tenantId: request?.body?.CampaignDetails?.tenantId,
            codes: boundary?.code,
            hierarchyType: request?.body?.CampaignDetails?.hierarchyType,
            includeChildren: true
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params);
        if (boundaryResponse?.TenantBoundary?.[0]) {
            logger.info("Boundary found " + JSON.stringify(boundaryResponse?.TenantBoundary?.[0]?.boundary));
            if (boundaryResponse?.TenantBoundary?.[0]?.boundary?.[0]?.children) {
                for (const childBoundary of boundaryResponse.TenantBoundary[0]?.boundary?.[0].children) {
                    await processBoundary(childBoundary, boundaryCodes, boundaries, request, true, boundary?.code);
                }
            }
        }
    }
}

async function addBoundaries(request: any) {
    var { boundaries } = request?.body?.CampaignDetails;
    var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
    for (const boundary of boundaries) {
        await processBoundary(boundary, boundaryCodes, boundaries, request, false);
    }
    request.body.CampaignDetails.boundaries = boundaries
}

async function addBoundariesForData(request: any, CampaignDetails: any) {
    var { boundaries } = CampaignDetails;
    var boundaryCodes = new Set(boundaries.map((boundary: any) => boundary.code));
    for (const boundary of boundaries) {
        await processBoundaryForData(boundary, boundaryCodes, boundaries, request, false);
    }
    CampaignDetails.boundaries = boundaries
}

function reorderBoundariesWithParentFirst(reorderedBoundaries: any[], boundaryProjectMapping: any) {
    // Function to get the index of a boundary in the original boundaries array
    function getIndex(code: any, boundaries: any[]) {
        return reorderedBoundaries.findIndex((boundary: any) => boundary.code === code);
    }
    // Reorder boundaries so that parents come first
    for (let i = 0; i < 2 * (reorderedBoundaries?.length); i++) {
        for (const boundary of reorderedBoundaries) {
            const parentCode = boundaryProjectMapping[boundary.code]?.parent;
            if (parentCode) {
                const parentIndex = getIndex(parentCode, reorderedBoundaries);
                const boundaryIndex = getIndex(boundary.code, reorderedBoundaries);

                if (parentIndex !== -1 && boundaryIndex !== -1 && parentIndex > boundaryIndex) {
                    reorderedBoundaries.splice(parentIndex + 1, 0, reorderedBoundaries.splice(boundaryIndex, 1)[0]);
                    break;
                }
            }
        }
    }
}

async function reorderBoundariesOfDataAndValidate(request: any, localizationMap?: any) {
    if (request?.body?.ResourceDetails?.campaignId) {
        const searchBody = {
            RequestInfo: request?.body?.RequestInfo,
            CampaignDetails: {
                ids: [request?.body?.ResourceDetails?.campaignId],
                tenantId: request?.body?.ResourceDetails?.tenantId
            }
        }
        const req: any = replicateRequest(request, searchBody)
        const response = await searchProjectTypeCampaignService(req)
        if (response?.CampaignDetails?.[0]) {
            const CampaignDetails = response?.CampaignDetails?.[0]
            await addBoundariesForData(request, CampaignDetails)
            logger.debug("Boundaries after addition " + getFormattedStringForDebug(CampaignDetails?.boundaries));
            await validateBoundaryOfResouces(CampaignDetails, request, localizationMap)
        }
        else {
            throwError("CAMPAIGN", 400, "CAMPAIGN_NOT_FOUND", "Campaign not found while Validating sheet boundaries");
        }
    }
}

async function reorderBoundaries(request: any, localizationMap?: any) {
    const rootBoundary = getRootBoundaryCode(request?.body?.CampaignDetails?.boundaries)
    request.body.boundaryProjectMapping = {}
    if (rootBoundary) {
        const params = {
            tenantId: request?.body?.CampaignDetails?.tenantId,
            codes: rootBoundary,
            hierarchyType: request?.body?.CampaignDetails?.hierarchyType,
            includeChildren: true
        }
        const boundaryResponse = await httpRequest(config.host.boundaryHost + config.paths.boundaryRelationship, request.body, params);
        if (boundaryResponse?.TenantBoundary?.[0]?.boundary) {
            const codesTargetMapping = await getCodesTarget(request, localizationMap)
            mapTargets(boundaryResponse?.TenantBoundary?.[0]?.boundary, codesTargetMapping)
            request.body.CampaignDetails.codesTargetMapping = codesTargetMapping
            logger.info("codesTargetMapping ");
            logger.debug("codesTargetMapping mapping :: " + getFormattedStringForDebug(codesTargetMapping));
            mapBoundariesParent(boundaryResponse?.TenantBoundary?.[0]?.boundary, request, null)
        }
    }
    await addBoundaries(request)
    logger.info("Boundaries for campaign creation in received")
    logger.debug("Boundaries after addition " + getFormattedStringForDebug(request?.body?.CampaignDetails?.boundaries));
    reorderBoundariesWithParentFirst(request?.body?.CampaignDetails?.boundaries, request?.body?.boundaryProjectMapping)
    logger.info("Reordered the Boundaries for mapping");
    logger.debug("Reordered Boundaries " + getFormattedStringForDebug(request?.body?.CampaignDetails?.boundaries));
}

function convertToProjectsArray(Projects: any, currentArray: any = []) {
    for (const project of Projects) {
        const descendants = project?.descendants
        delete project?.descendants
        currentArray.push(project);
        if (descendants && Array.isArray(descendants) && descendants?.length > 0) {
            convertToProjectsArray(descendants, currentArray)
        }
    }
    return currentArray;
}

async function getRelatedProjects(request: any) {
    const { projectId, tenantId } = request?.body?.CampaignDetails;
    const projectSearchBody = {
        RequestInfo: request?.body?.RequestInfo,
        Projects: [
            {
                id: projectId,
                tenantId: tenantId
            }
        ]
    }
    const projectSearchParams = {
        tenantId: tenantId,
        offset: 0,
        limit: 1,
        includeDescendants: true
    }
    logger.info("Project search params " + JSON.stringify(projectSearchParams))
    logger.info("Project search body " + JSON.stringify(projectSearchBody))
    logger.info("Project search url " + config?.host?.projectHost + config?.paths?.projectSearch)
    const projectSearchResponse = await httpRequest(config?.host?.projectHost + config?.paths?.projectSearch, projectSearchBody, projectSearchParams);
    if (projectSearchResponse?.Project && Array.isArray(projectSearchResponse?.Project) && projectSearchResponse?.Project?.length > 0) {
        return convertToProjectsArray(projectSearchResponse?.Project)
    }
    else {
        throwError("PROJECT", 500, "PROJECT_SEARCH_ERROR")
        return []
    }
}

async function updateProjectDates(request: any) {
    const projects = await getRelatedProjects(request);
    const { startDate, endDate } = request?.body?.CampaignDetails;
    for (const project of projects) {
        project.startDate = startDate || project.startDate;
        project.endDate = endDate || project.endDate;
        delete project?.address;
    }
    logger.info("Projects related to current Campaign : " + JSON.stringify(projects));
    const projectUpdateBody = {
        RequestInfo: request?.body?.RequestInfo,
        Projects: projects
    }
    const projectUpdateResponse = await httpRequest(config?.host?.projectHost + config?.paths?.projectUpdate, projectUpdateBody);
    if (projectUpdateResponse?.Project && Array.isArray(projectUpdateResponse?.Project) && projectUpdateResponse?.Project?.length == projects?.length) {
        logger.info("Project dates updated successfully")
    }
    else {
        throwError("PROJECT", 500, "PROJECT_UPDATE_ERROR")
    }
}

async function getCodesTarget(request: any, localizationMap?: any) {
    const { tenantId, resources } = request?.body?.CampaignDetails;
    const boundaryWithTargetResource = resources?.filter((resource: any) => resource?.type == "boundaryWithTarget");
    const fileId = boundaryWithTargetResource[0]?.filestoreId
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: tenantId, fileStoreIds: fileId }, "get");
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 500, "DOWNLOAD_URL_NOT_FOUND");
    }
    const targetData = await getTargetSheetData(fileResponse?.fileStoreIds?.[0]?.url, true, true);
    const boundaryTargetMapping: any = {};
    const codeColumnName = getLocalizedName(createAndSearch?.boundaryWithTarget?.boundaryValidation?.column, localizationMap)
    // Iterate through each key in targetData
    for (const key in targetData) {
        // Iterate through each entry in the array under the current key
        targetData[key].forEach(entry => {
            // Check if the entry has both "Boundary Code" and "Target at the Selected Boundary level"
            if (entry[codeColumnName] !== undefined && entry['Target at the Selected Boundary level'] !== undefined) {
                // Add the mapping to the boundaryTargetMapping object
                boundaryTargetMapping[entry[codeColumnName]] = entry['Target at the Selected Boundary level'];
            }
        });
    }
    return boundaryTargetMapping;
}

async function createProject(request: any, actionUrl: any, localizationMap?: any) {
    logger.info("Create Projects started for the given Campaign")
    var { tenantId, boundaries, projectType, projectId, startDate, endDate } = request?.body?.CampaignDetails;
    if (boundaries && projectType && !projectId) {
        const projectTypeResponse = await getMDMSV1Data({}, 'HCM-PROJECT-TYPES', "projectTypes", tenantId);
        var Projects: any = enrichProjectDetailsFromCampaignDetails(request?.body?.CampaignDetails, projectTypeResponse);
        const projectCreateBody = {
            RequestInfo: request?.body?.RequestInfo,
            Projects
        }
        await reorderBoundaries(request, localizationMap)
        boundaries = request?.body?.CampaignDetails?.boundaries;
        for (const boundary of boundaries) {
            Projects[0].address = { tenantId: tenantId, boundary: boundary?.code, boundaryType: boundary?.type }
            if (request?.body?.boundaryProjectMapping?.[boundary?.code]?.parent) {
                const parent = request?.body?.boundaryProjectMapping?.[boundary?.code]?.parent
                Projects[0].parent = request?.body?.boundaryProjectMapping?.[parent]?.projectId
            }
            else {
                Projects[0].parent = null
            }
            Projects[0].referenceID = request?.body?.CampaignDetails?.id
            Projects[0].targets = [
                {
                    beneficiaryType: request?.body?.CampaignDetails?.additionalDetails?.beneficiaryType,
                    totalNo: request?.body?.CampaignDetails?.codesTargetMapping[boundary?.code],
                    targetNo: request?.body?.CampaignDetails?.codesTargetMapping[boundary?.code]
                }
            ]
            await projectCreate(projectCreateBody, request)
            await new Promise(resolve => setTimeout(resolve, 3000));
        }
    }
    else if ((startDate || endDate) && projectId && actionUrl == "update") {
        await updateProjectDates(request);
    }
}


async function processAfterPersist(request: any, actionInUrl: any) {
    try {
        const localizationMap = await getLocalizedMessagesHandler(request, request?.body?.CampaignDetails?.tenantId);
        if (request?.body?.CampaignDetails?.action == "create") {
            await createProjectCampaignResourcData(request);
            await createProject(request, actionInUrl, localizationMap)
            await enrichAndPersistProjectCampaignRequest(request, actionInUrl, false, localizationMap)
        }
        else {
            await enrichAndPersistProjectCampaignRequest(request, actionInUrl, false, localizationMap)
        }
    } catch (error: any) {
        logger.error(error)
        enrichAndPersistCampaignWithError(request?.body, error)
    }
}

async function processBasedOnAction(request: any, actionInUrl: any) {
    if (actionInUrl == "create") {
        request.body.CampaignDetails.id = uuidv4()
    }
    await enrichAndPersistProjectCampaignRequest(request, actionInUrl, true)
    processAfterPersist(request, actionInUrl)
}
async function appendSheetsToWorkbook(request: any, boundaryData: any[], differentTabsBasedOnLevel: any, localizationMap?: any) {
    try {
        logger.info("Received Boundary data for Processing file")
        const uniqueDistrictsForMainSheet: string[] = [];
        const workbook = XLSX.utils.book_new();
        const type = request?.query?.type
        const headingInSheet = headingMapping?.[type]
        const localisedHeading = getLocalizedName(headingInSheet, localizationMap)
        await createReadMeSheet(request, workbook, localisedHeading, localizationMap);
        const mainSheetData: any[] = [];
        const headersForMainSheet = differentTabsBasedOnLevel ? Object.keys(boundaryData[0]).slice(0, Object.keys(boundaryData[0]).indexOf(differentTabsBasedOnLevel) + 1) : [];
        const localizedHeadersForMainSheet = getLocalizedHeaders(headersForMainSheet, localizationMap);
        const localizedBoundaryCode = getLocalizedName(getBoundaryColumnName(), localizationMap);
        localizedHeadersForMainSheet.push(localizedBoundaryCode);
        mainSheetData.push([...localizedHeadersForMainSheet]);
        const districtLevelRowBoundaryCodeMap = new Map();
        for (const data of boundaryData) {
            const modifiedData = modifyDataBasedOnDifferentTab(data, differentTabsBasedOnLevel, localizationMap);
            const rowData = Object.values(modifiedData);
            const districtIndex = modifiedData[differentTabsBasedOnLevel] !== '' ? rowData.indexOf(data[differentTabsBasedOnLevel]) : -1;
            if (districtIndex == -1) {
                mainSheetData.push(rowData);
            }
            else {
                const districtLevelRow = rowData.slice(0, districtIndex + 1);
                if (!uniqueDistrictsForMainSheet.includes(districtLevelRow.join('_'))) {
                    uniqueDistrictsForMainSheet.push(districtLevelRow.join('_'));
                    districtLevelRowBoundaryCodeMap.set(districtLevelRow.join('_'), data[getLocalizedName(getBoundaryColumnName(), localizationMap)]);
                    mainSheetData.push(rowData);
                }
            }
        }
        const mainSheet = XLSX.utils.aoa_to_sheet(mainSheetData);
        const localizedBoundaryTab = getLocalizedName(getBoundaryTabName(), localizationMap);
        const columnWidths = Array(12).fill({ width: 30 });
        mainSheet['!cols'] = columnWidths;
        XLSX.utils.book_append_sheet(workbook, mainSheet, localizedBoundaryTab);
        for (const uniqueData of uniqueDistrictsForMainSheet) {
            const uniqueDataFromLevelForDifferentTabs = uniqueData.slice(uniqueData.lastIndexOf('_') + 1);
            const districtDataFiltered = boundaryData.filter(boundary => boundary[differentTabsBasedOnLevel] === uniqueDataFromLevelForDifferentTabs);
            const modifiedFilteredData = modifyFilteredData(districtDataFiltered, districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap);
            if (modifiedFilteredData?.[0]) {
                const districtIndex = Object.keys(modifiedFilteredData[0]).indexOf(differentTabsBasedOnLevel);
                const headers = Object.keys(modifiedFilteredData[0]).slice(districtIndex);
                const modifiedHeaders = [...headers, "HCM_ADMIN_CONSOLE_TARGET"];
                const localizedHeaders = getLocalizedHeaders(modifiedHeaders, localizationMap);
                const newSheetData = [localizedHeaders];

                for (const data of modifiedFilteredData) {
                    const rowData = Object.values(data).slice(districtIndex).map(value => value === null ? '' : String(value)); // Replace null with empty string
                    newSheetData.push(rowData);
                }
                const ws = XLSX.utils.aoa_to_sheet(newSheetData);
                const localizedDifferentTabsName = getLocalizedName(districtLevelRowBoundaryCodeMap.get(uniqueData), localizationMap);
                ws['!cols'] = columnWidths;
                XLSX.utils.book_append_sheet(workbook, ws, localizedDifferentTabsName);
            }
        }
        logger.info("File processed successfully")

        return workbook;
    } catch (error) {
        throw Error("An error occurred while creating tabs based on district:");
    }
}
function modifyFilteredData(districtDataFiltered: any, targetBoundaryCode: any, localizationMap?: any): any {

    // Step 2: Slice the boundary code up to the last underscore
    const slicedBoundaryCode = targetBoundaryCode.slice(0, targetBoundaryCode.lastIndexOf('_') + 1);

    // Step 3: Filter the rows that contain the sliced boundary code
    const modifiedFilteredData = districtDataFiltered.filter((row: any, index: any) => {
        // Extract the boundary code from the current row
        const localizedBoundaryCode = getLocalizedName(getBoundaryColumnName(), localizationMap);
        const boundaryCode = row[localizedBoundaryCode];
        // Check if the boundary code starts with the sliced boundary code
        return boundaryCode.startsWith(slicedBoundaryCode);
    });
    // Step 4: Return the modified filtered data
    return modifiedFilteredData;
}

async function generateFilteredBoundaryData(request: any, responseFromCampaignSearch: any) {
    const rootBoundary: any = (responseFromCampaignSearch?.Filters?.boundaries).filter((boundary: any) => boundary.isRoot);
    const params = {
        ...request?.query,
        includeChildren: true,
        codes: rootBoundary?.[0]?.code
    };
    const boundaryDataFromRootOnwards = await getBoundaryRelationshipData(request, params);
    logger.info(`filtering the boundaries`);
    const filteredBoundaryList = filterBoundaries(boundaryDataFromRootOnwards, responseFromCampaignSearch?.Filters)
    logger.info(`filtered the boundaries based on given criteria`)
    return filteredBoundaryList;
}

function filterBoundaries(boundaryData: any[], filters: any): any {
    function filterRecursive(boundary: any): any {
        const boundaryFilters = filters && filters.boundaries; // Accessing boundaries array from filters object
        const filter = boundaryFilters?.find((f: any) => f.code === boundary.code && f.boundaryType === boundary.boundaryType);

        if (!filter) {
            return {
                ...boundary,
                children: boundary.children.map(filterRecursive)
            };
        }

        if (!boundary.children.length) {
            if (!filter.includeAllChildren) {
                // throwError("COMMON", 400, "VALIDATION_ERROR", "Boundary cannot have includeAllChildren filter false if it does not have any children");
                logger.error("Boundary cannot have includeAllChildren filter false if it does not have any children");
            }
            // If boundary has no children and includeAllChildren is true, return as is
            return {
                ...boundary,
                children: []
            };
        }

        if (filter.includeAllChildren) {
            // If includeAllChildren is true, return boundary with all children
            return {
                ...boundary,
                children: boundary.children.map(filterRecursive)
            };
        }

        const filteredChildren: any[] = [];
        boundary.children.forEach((child: any) => {
            const matchingFilter = boundaryFilters.find((f: any) => f.code === child.code && f.boundaryType === child.boundaryType);
            if (matchingFilter) {
                filteredChildren.push(filterRecursive(child));
            }
        });
        return {
            ...boundary,
            children: filteredChildren
        };
    }
    const filteredData = boundaryData.map(filterRecursive);
    return filteredData;
}


function generateHierarchy(boundaries: any[]) {
    // Create an object to store boundary types and their parents
    const parentMap: any = {};

    // Populate the object with boundary types and their parents
    for (const boundary of boundaries) {
        parentMap[boundary.boundaryType] = boundary.parentBoundaryType;
    }

    // Traverse the hierarchy to generate the hierarchy list
    const hierarchyList = [];
    for (const boundaryType in parentMap) {
        if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
            const parentBoundaryType = parentMap[boundaryType];
            if (parentBoundaryType === null) {
                // This boundary type has no parent, add it to the hierarchy list
                hierarchyList.push(boundaryType);
                // Traverse its children recursively
                traverseChildren(boundaryType, parentMap, hierarchyList);
            }
        }
    }
    return hierarchyList;
}

function traverseChildren(parent: any, parentMap: any, hierarchyList: any[]) {
    for (const boundaryType in parentMap) {
        if (Object.prototype.hasOwnProperty.call(parentMap, boundaryType)) {
            const parentBoundaryType = parentMap[boundaryType];
            if (parentBoundaryType === parent) {
                // This boundary type has the current parent, add it to the hierarchy list
                hierarchyList.push(boundaryType);
                // Traverse its children recursively
                traverseChildren(boundaryType, parentMap, hierarchyList);
            }
        }
    }
}

function createBoundaryMap(boundaries: any[], boundaryMap: Map<string, string>): void {
    for (const boundary of boundaries) {
        boundaryMap.set(boundary.code, boundary.boundaryType);
        if (boundary.children.length > 0) {
            createBoundaryMap(boundary.children, boundaryMap);
        }
    }
}

async function boundaryBulkUpload(request: any, localizationMap?: any) {
    try {
        logger.info("Boundary Relationship Creation Starts");
        await autoGenerateBoundaryCodes(request, localizationMap);
        await generateProcessedFileAndPersist(request);
    }
    catch (error: any) {
        await handleResouceDetailsError(request, error)
    }
}

const autoGenerateBoundaryCodes = async (request: any, localizationMap?: any) => {
    const { hierarchyType, tenantId } = request?.body?.ResourceDetails || {};
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId, fileStoreIds: request?.body?.ResourceDetails?.fileStoreId }, "get");
    const localizedBoundaryTab = getLocalizedName(getBoundaryTabName(), localizationMap);
    const boundaryData = await getSheetData(fileResponse?.fileStoreIds?.[0]?.url, localizedBoundaryTab, false, undefined, localizationMap);
    const updatedBoundaryData = updateBoundaryData(boundaryData);
    const hierarchy = await getHierarchy(request, tenantId, hierarchyType) || [];
    const modifiedBoundaryData = modifyBoundaryDataHeaders(updatedBoundaryData, hierarchy, localizationMap);
    const [withBoundaryCode, withoutBoundaryCode] = modifyBoundaryData(modifiedBoundaryData, localizationMap);
    const { mappingMap, countMap } = getCodeMappingsOfExistingBoundaryCodes(withBoundaryCode);
    const childParentMap = getChildParentMap(withoutBoundaryCode);
    const boundaryMap = await getAutoGeneratedBoundaryCodesHandler(withoutBoundaryCode, childParentMap, mappingMap, countMap, request);
    logger.info("Boundary Code Auto Generation Completed");
    await createBoundaryEntities(request, boundaryMap);
    const modifiedChildParentMap = modifyChildParentMap(childParentMap, boundaryMap);
    await createBoundaryRelationship(request, boundaryMap, modifiedChildParentMap);
    const boundaryDataForSheet = addBoundaryCodeToData(withBoundaryCode, withoutBoundaryCode, boundaryMap);
    logger.info("Initiated the localisation message creation for the uploaded boundary");
    transformAndCreateLocalisation(boundaryMap, request);
    const modifiedHierarchy = hierarchy.map(ele => `${hierarchyType}_${ele}`.toUpperCase())
    const headers = [...modifiedHierarchy, config.boundaryCode];
    const data = prepareDataForExcel(boundaryDataForSheet, hierarchy, boundaryMap);
    const localizedHeaders = getLocalizedHeaders(headers, localizationMap);
    const boundarySheetData = await createExcelSheet(data, localizedHeaders, localizedBoundaryTab);
    const boundaryFileDetails: any = await createAndUploadFile(boundarySheetData?.wb, request);
    request.body.ResourceDetails.processedFileStoreId = boundaryFileDetails?.[0]?.fileStoreId;
}



function updateBoundaryData(boundaryData: any[]): any[] {
    const map: Map<string, string> = new Map();
    const count: Map<string, number> = new Map();

    boundaryData.forEach((row) => {
        const keys = Object.keys(row);
        keys.forEach((key, index) => {
            if (index > 0) {
                const element = row[key];
                const previousKey = keys[index - 1];
                const previousElement = row[keys[index - 1]];
                const previousElementKey = `${previousKey}:${previousElement}`;
                const elementKey = `${key}:${element}`;

                if (!map.has(elementKey)) {
                    map.set(elementKey, previousElementKey);
                    count.set(elementKey, 1);
                } else {
                    const currentCount = count.get(elementKey)!;
                    if (map.get(elementKey) !== previousElementKey) {
                        map.set(elementKey, previousElementKey);
                        count.set(elementKey, currentCount + 1);
                    }
                    const uniqueCount = count.get(elementKey)!;
                    const uniqueElement = (uniqueCount > 1) ? `${element}-${(uniqueCount - 1).toString().padStart(2, '0')}` : `${element}`;
                    row[key] = uniqueElement;
                }
            }
        });
    });
    return boundaryData;
}

function modifyBoundaryDataHeaders(boundaryData: any[], hierarchy: any[], localizationMap?: any) {
    const updatedData = boundaryData.map((obj: any) => {
        const updatedObj: { [key: string]: string | undefined } = {}; // Updated object with modified keys

        let hierarchyIndex = 0; // Track the index of the hierarchy array

        for (const key in obj) {
            if (key != getLocalizedName(config.boundaryCode, localizationMap)) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) {
                    const hierarchyKey = hierarchy[hierarchyIndex]; // Get the key from the hierarchy array
                    updatedObj[hierarchyKey] = obj[key]; // Map the key to the updated object
                    hierarchyIndex++; // Move to the next key in the hierarchy array
                }
            }
            else {
                updatedObj[key] = obj[key];
            }
        }


        return updatedObj;
    });
    return updatedData;
}

function modifyChildParentMap(childParentMap: Map<any, any>, boundaryMap: Map<any, any>): Map<string, string | null> {
    const modifiedMap: Map<string, string | null> = new Map();

    // Iterate over each entry in childParentMap
    childParentMap.forEach((value, key) => {
        // Get the modified key and value from boundaryMap
        const modifiedKey = findMapValue(boundaryMap, key) || null;
        const modifiedValue = value ? findMapValue(boundaryMap, value) : null;

        // Set the modified key-value pair in modifiedMap
        modifiedMap.set(modifiedKey, modifiedValue);
    });

    return modifiedMap;
}


async function convertSheetToDifferentTabs(request: any, boundaryData: any, differentTabsBasedOnLevel: any, localizationMap?: any) {
    // create different tabs on the level of hierarchy we want to 
    const updatedWorkbook = await appendSheetsToWorkbook(request, boundaryData, differentTabsBasedOnLevel, localizationMap);
    // upload the excel and generate file store id
    const boundaryDetails = await createAndUploadFile(updatedWorkbook, request);
    return boundaryDetails;
}

async function getBoundaryDataAfterGeneration(result: any, request: any, localizationMap?: any) {
    const fileStoreId = result[0].fileStoreId;
    const fileResponse = await httpRequest(config.host.filestore + config.paths.filestore + "/url", {}, { tenantId: request?.query?.tenantId, fileStoreIds: fileStoreId }, "get");
    if (!fileResponse?.fileStoreIds?.[0]?.url) {
        throwError("FILE", 400, "INVALID_FILE");
    }
    const boundaryData = await getSheetData(fileResponse?.fileStoreIds?.[0]?.url, getBoundaryTabName(), false, undefined, localizationMap);
    return boundaryData;
}

function getLocalizedName(expectedName: string, localizationMap?: { [key: string]: string }) {
    if (!localizationMap || !(expectedName in localizationMap)) {
        return expectedName;
    }
    const localizedName = localizationMap[expectedName];
    return localizedName;
}

async function getTargetBoundariesRelatedToCampaignId(request: any, localizationMap?: any) {
    let CampaignDetails: any;
    if (request?.body?.ResourceDetails?.campaignId) {
        const searchBody = {
            RequestInfo: request?.body?.RequestInfo,
            CampaignDetails: {
                ids: [request?.body?.ResourceDetails?.campaignId],
                tenantId: request?.body?.ResourceDetails?.tenantId
            }
        }
        const req: any = replicateRequest(request, searchBody)
        const response = await searchProjectTypeCampaignService(req)
        if (response?.CampaignDetails?.[0]) {
            CampaignDetails = response?.CampaignDetails?.[0]
            await addBoundariesForData(request, CampaignDetails)
        }
        else {
            throwError("CAMPAIGN", 400, "CAMPAIGN_NOT_FOUND", "Campaign not found while Validating sheet boundaries");
        }
    }
    return CampaignDetails?.boundaries;
}





export {
    generateProcessedFileAndPersist,
    convertToTypeData,
    getChildParentMap,
    addBoundaryCodeToData,
    prepareDataForExcel,
    extractCodesFromBoundaryRelationshipResponse,
    searchProjectCampaignResourcData,
    processDataSearchRequest,
    getCodeMappingsOfExistingBoundaryCodes,
    processBasedOnAction,
    appendSheetsToWorkbook,
    generateFilteredBoundaryData,
    generateHierarchy,
    createBoundaryMap,
    autoGenerateBoundaryCodes,
    convertSheetToDifferentTabs,
    getBoundaryDataAfterGeneration,
    boundaryBulkUpload,
    enrichAndPersistCampaignWithError,
    getLocalizedName,
    reorderBoundaries,
    reorderBoundariesOfDataAndValidate,
    getTargetBoundariesRelatedToCampaignId
}
